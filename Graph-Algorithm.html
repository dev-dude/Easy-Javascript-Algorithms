<script>
    // FROM HERE - FOR PERSONAL USE
    // https://github.com/mgechev/javascript-algorithms/blob/master/src/graphs/searching/dfs.js
    // http://www.stoimen.com/blog/2012/09/17/computer-algorithms-graph-depth-first-search/
    // http://www.stoimen.com/blog/2012/08/31/computer-algorithms-graphs-and-their-representation
   // https://github.com/oreillymedia/data_structures_and_algorithms_using_javascript

    function Graph() {

        var vertices = []; //list

        var adjList = new Dictionary();

        this.addVertex = function(v){
            vertices.push(v);
            adjList.set(v, []); //initialize adjacency list with array as well;
        };

        this.addEdge = function(v, w){
            adjList.get(v).push(w);
            //adjList.get(w).push(v); //commented to run the improved DFS with topological sorting
        };
    }

    var graph =[
            [0, 1, 1, 0, 0, 0],
            [1, 0, 0, 1, 0, 0],
            [1, 0, 0, 1, 0, 0],
            [0, 1, 1, 0, 1, 0],
            [0, 0, 0, 1, 0, 1],
            [0, 0, 0, 0, 1, 0]
    ];

    function dfs(graph, start, targetNode) {
        var stack = [],
            visited = [],
            node;
        stack.push(start);
        visited[start] = true;
        while (stack.length) {
            node = stack.pop();
            console.log(node);
            if (node === targetNode) {
                return true;
            }
            for (var i = 0; i < graph[node].length; i ++) {
                if (graph[node][i] && !visited[i]) {
                    stack.push(i);
                    visited[i] = true;
                }
            }
        }
        return false;
    }

    function buildPath(parents, targetNode) {
        var result = [targetNode];
        while (parents[targetNode] !== null) {
            targetNode = parents[targetNode];
            result.push(targetNode);
        }
        return result.reverse();
    }

    function bfs (graph, startNode, targetNode) {
        var parents = [];
        var queue = [];
        var visited = [];
        var node;
        queue.push(startNode);
        parents[startNode] = null;
        visited[startNode] = true;
        console.log(startNode);
        console.log('---');
        while (queue.length) {
            node = queue.shift();
            if (node === targetNode) {
                return buildPath(parents, targetNode);
            }
            for (var i = 0; i < graph.length; i ++) {
                if (i !== node && graph[node][i] && !visited[i]) {
                    parents[i] = node;
                    visited[i] = true;
                    queue.push(i);
                    console.log(i);
                }




            }
            console.log('---');
        }
        return null;
    }
    bfs (graph, 2);
    dfs (graph, 2);



    // Better Graph Example:

    function Graph(directed) {
        this.directed = !!directed;
        this.vertices = {};
        this.edges = {};

        this.addVertex = function(vertex) {
            if (!this.vertices[vertex.id]) {
                this.vertices[vertex.id] = vertex;
            }
        };

        // Adjacency map representation
        this.addEdge = function(vertex1, vertex2) {
            if (!this.edges[vertex1.id]) {
                this.edges[vertex1.id] = {};
            }
            if (!this.directed) {
                if (!this.edges[vertex2.id]) {
                    this.edges[vertex2.id] = {};
                }
            }
        };
    }

    function Graph(v) {
        this.vertices = v;
        this.vertexList = [];
        this.edges = 0;
        this.adj = [];
        for (var i = 0; i < this.vertices; ++i) {
            this.adj[i] = [];
            this.adj[i].push("");
        }
        this.addEdge = addEdge;
        this.showGraph = showGraph;
        this.dfs = dfs;
        this.marked = [];
        for (var i = 0; i < this.vertices; ++i) {
            this.marked[i] = false;
        }
        this.bfs = bfs;
        this.edgeTo = [];
        this.hasPathTo = hasPathTo;
        this.pathTo = pathTo;
        this.topSortHelper = topSortHelper;
        this.topSort = topSort;

    }

    function topSort() {
        var stack = [];
        var visited = [];
        for (var i = 0; i < this.vertices; i++) {
            visited[i] = false;
        }
        for (var i = 0; i < this.vertices; i++) {
            if (visited[i] == false) {
                this.topSortHelper(i, visited, stack);
            }
        }
        for (var i = 0; i < stack.length; i++) {
            if (stack[i] != undefined && stack[i] != false) {
                print(this.vertexList[stack[i]]);
            }
        }
    }

    function topSortHelper(v, visited, stack) {
        visited[v] = true;
        for each (var w in this.adj[v]) {
            if (!visited[w]) {
                this.topSortHelper(visited[w], visited, stack);
            }
        }
        stack.push(v);
    }

    function addEdge(v,w) {
        this.adj[v].push(w);
        this.adj[w].push(v);
        this.edges++;
    }

    /*function showGraph() {
     for (var i = 0; i < this.vertices; ++i) {
     putstr(i + " -> ");
     for (var j = 0; j < this.vertices; ++j) {
     if (this.adj[i][j] != undefined)
     putstr(this.adj[i][j] + ' ');
     }
     print();
     }
     }*/

    // a new function to display symbolic names instead of numbers
    function showGraph() {
        var visited = [];
        for (var i = 0; i < this.vertices; ++i) {
            putstr(this.vertexList[i] + " -> ");
            visited.push(this.vertexList[i]);
            for (var j = 0; j < this.vertices; ++j) {
                if (this.adj[i][j] != undefined) {
                    if (visited.indexOf(this.vertexList[j]) < 0) {
                        putstr(this.vertexList[j] + ' ');
                    }
                }
            }
            print();
            visited.pop();
        }
    }

    function dfs(v) {
        this.marked[v] = true;
        if (this.adj[v] != undefined) {
            print("Visited vertex: " + v);
        }
        for each (var w in this.adj[v]) {
            if (!this.marked[w]) {
                this.dfs(w);
            }
        }
    }

    function bfs(s) {
        var queue = [];
        this.marked[s] = true;
        queue.unshift(s);
        while (queue.length > 0) {
            var v = queue.shift();
            if (typeof(v) != "string") {
                print("Visited vertex: " + v);
            }
            for each (var w in this.adj[v]) {
                if (!this.marked[w]) {
                    this.edgeTo[w] = v;
                    this.marked[w] = true;
                    queue.unshift(w);
                }
            }
        }
    }

    function hasPathTo(v) {
        return this.marked[v];
    }

    function pathTo(v) {
        var source = 0;
        if (!this.hasPathTo(v)) {
            return undefined;
        }
        var path = [];
        for (var i = v; i != source; i = this.edgeTo[i]) {
            path.push(i);
        }
        path.push(s);
        return path;
    }

</script>
<html>
</html>
